const numIslands = (grid) => {
  if (grid.length === 0) return 0
  if (grid[0].length === 0) return 0
  let count = 0

  for (let row = 0; row < grid.length; row++) {
    for (let col = 0; col < grid[0].length; col++) {
      if (grid[row][col] === '1') {
        count = count + 1
        grid[row][col] = 0

        const queue = []
        queue.push({ row, col })

        while (queue.length) {
          const popped = queue.shift()
          pushToQueue(grid, popped.row - 1, popped.col, queue)
          pushToQueue(grid, popped.row, popped.col + 1, queue)
          pushToQueue(grid, popped.row + 1, popped.col, queue)
          pushToQueue(grid, popped.row, popped.col - 1, queue)
        }
      }
    }
  }

  return count
}

const pushToQueue = (grid, row, col, queue) => {
  if (
    row >= 0 &&
    col >= 0 &&
    row < grid.length &&
    col < grid[0].length &&
    grid[row][col] === '1'
  ) {
    queue.push({ row, col })
    grid[row][col] = '0'
  }
}

const grid = [
  ['1', '1', '1', '1', '0'],
  ['1', '1', '0', '1', '0'],
  ['1', '1', '0', '0', '1'],
  ['0', '0', '0', '1', '1'],
]
const grid2 = [
  ['0', '1', '0', '1', '0'],
  ['1', '0', '1', '0', '1'],
  ['0', '1', '1', '1', '0'],
  ['1', '0', '1', '0', '1'],
]

const grid3 = [
  [
    '1',
    '1',
    '1',
    '1',
    '1',
    '0',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '0',
    '1',
    '0',
    '1',
    '1',
  ],
  [
    '0',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '0',
    '1',
    '1',
    '1',
    '1',
    '1',
    '0',
  ],
  [
    '1',
    '0',
    '1',
    '1',
    '1',
    '0',
    '0',
    '1',
    '1',
    '0',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
  ],
  [
    '1',
    '1',
    '1',
    '1',
    '0',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
  ],
  [
    '1',
    '0',
    '0',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
  ],
  [
    '1',
    '0',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '0',
    '1',
    '1',
    '1',
    '0',
    '1',
    '1',
    '1',
    '0',
    '1',
    '1',
    '1',
  ],
  [
    '0',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '0',
    '1',
    '1',
    '0',
    '1',
    '1',
    '1',
    '1',
  ],
  [
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '0',
    '1',
    '1',
    '1',
    '1',
    '0',
    '1',
    '1',
  ],
  [
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '0',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
  ],
  [
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
  ],
  [
    '0',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '0',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
  ],
  [
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
  ],
  [
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
  ],
  [
    '1',
    '1',
    '1',
    '1',
    '1',
    '0',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '0',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
  ],
  [
    '1',
    '0',
    '1',
    '1',
    '1',
    '1',
    '1',
    '0',
    '1',
    '1',
    '1',
    '0',
    '1',
    '1',
    '1',
    '1',
    '0',
    '1',
    '1',
    '1',
  ],
  [
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '0',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '0',
  ],
  [
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '0',
    '1',
    '1',
    '1',
    '1',
    '0',
    '0',
  ],
  [
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
  ],
  [
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
  ],
  [
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
    '1',
  ],
]

console.log(numIslands(grid3))

/*
######### nested loop with another nested while, but time is: O(n). 
  more specifically O(m*n) -> m is len of arr, n is len of outer arr

  space is : O(max(m, n)) -> in bfs we max store len of adjacent matrix in queue

  ** if we perform dfs in worst case, we need to store all in stack/call stack 
  so space is: O(m * n). In higher level overview it is: O(n)
*/
